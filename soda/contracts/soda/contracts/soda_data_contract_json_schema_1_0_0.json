{
    "$schema": "http://json-schema.org/draft-04/schema#",
    "$id": "https://soda.io/soda_data_contract_json_schema_1_0_0.json",
    "title": "Soda data contract",
    "description": "A data contract",
    "type": "object",
    "properties": {
        "schema_version": {
            "description": "Version of the Soda data contract schema. Uses semantic versioning. Eg 1.0.0",
            "type": "string",
            "enum": ["1.0.0"]
        },
        "version": {
            "description": "Version of the contract. Use semantic versioning. Eg 1.0.0",
            "type": "string",
            "minLength": 5,
            "maxLength": 14,
            "pattern": "^(?:0|[1-9]\\d*)\\.(?:0|[1-9]\\d*)\\.(?:0|[1-9]\\d*)$"
        },
        "dataset": {
            "description": "The name of the dataset",
            "type": "string"
        },
        "columns": {
            "description": "The schema",
            "type": "array",
            "items": {
                "type": "object",
                "properties": {
                    "name": {
                        "description": "The name of the column as in the SQL warehouse",
                        "type": "string"
                    },
                    "description": {
                        "description": "The description to be used anywhere this column is shown to users",
                        "type": "string"
                    },
                    "data_type": {
                        "description": "The SQL data type as in the warehouse",
                        "anyOf": [
                            {
                                "type": "string"
                            },
                            {
                                "type": "string",
                                "enum": [
                                    "VARCHAR", "CHAR", "TEXT", "STRING",
                                    "INT", "SMALLINT", "TINYINT", "BIGINT", "INTEGER",
                                    "DECIMAL", "NUMERIC", "DOUBLE", "PRECISION", "DOUBLE PRECISION", "FLOAT", "FLOAT4", "FLOAT8", "REAL",
                                    "CLOB", "BLOB", "BINARY", "VARBINARY",
                                    "JSON", "JSONB", "XML",
                                    "BOOLEAN",
                                    "DATE",
                                    "TIME",
                                    "TIMESTAMP", "TIMESTAMP_TZ"
                                ]
                            }
                        ]
                    },
                    "not_null": {
                        "description": "No missing value are allowed if set to true. Default is false. Implies a missing_count check in Soda. Consider customizing the list of missing values with missing_* properties.",
                        "type": "boolean",
                        "default": true
                    },
                    "missing_values": {
                        "description": "Customized list of missing values. NULL is always considered missing so that does not have to be specified. If no customization is needed, consider specifying not_null:true instead. Implies a missing_count check in Soda.",
                        "type": "array",
                        "items": {
                            "type": ["integer", "string"]
                        }
                    },
                    "missing_sql_regex": {
                        "description": "Customized SQL regex to identify missing values. The flavor of regex depends on the SQL engine / warehouse. NULL is always considered missing so that does not have to be specified. Implies a missing_count check in Soda.",
                        "type": "string"
                    },
                    "valid_values": {
                        "description": "A list of valid values. Only supports all strings or all numbers. Implies an invalid_count check in Soda.",
                        "type": "array",
                        "items": {
                            "type": ["number", "string"]
                        }
                    },
                    "valid_sql_regex": {
                        "description": "A SQL regular expression that matches valid values. Implies a valid_count check in Soda. All (in)valid_* configs are combined in a single invalid_count check.",
                        "type": "string"
                    },
                    "valid_format": {
                        "description": "A named regular expression that specifies valid values.",
                        "$ref": "#/$defs/format"
                    },
                    "valid_length": {
                        "description": "The exact length of values. Only for text data types. Implies an invalid_count check in Soda. Also consider valid_min_length & valid_max_length.",
                        "type": "integer"
                    },
                    "valid_max_length": {
                        "description": "The maximum length of values. Only for text data types. Implies an invalid_count check in Soda.",
                        "type": "integer"
                    },
                    "valid_min_length": {
                        "description": "The minimum length of values. Only for text data types. Implies an invalid_count check in Soda.",
                        "type": "integer"
                    },
                    "valid_min": {
                        "description": "The minimum allowed value. Only for numeric data types or text types with a numeric format. Implies an invalid_count check in Soda.",
                        "type": "integer"
                    },
                    "valid_max": {
                        "description": "The maximum allowed value. Only for numeric data types or text types with a numeric format. Implies an invalid_count check in Soda.",
                        "type": "integer"
                    },
                    "invalid_values": {
                        "description": "A list of valid values. Only supports all strings or all numbers. Implies an invalid_count check in Soda.",
                        "type": "array",
                        "items": {
                            "type": ["number", "string"]
                        }
                    },
                    "invalid_sql_regex": {
                        "description": "A regular expression that specifies valid values.",
                        "type": "string"
                    },
                    "invalid_format": {
                        "description": "A named regular expression that specifies invalid values.",
                        "$ref": "#/$defs/format"
                    },
                    "unique": {
                        "description": "No duplicates allowed if set to true. Triggers a duplicate_count check in Soda.",
                        "type": "boolean",
                        "default": true
                    },
                    "optional": {
                        "description": "When set to true, the schema check will not fail if the column is not present. Default is required.",
                        "type": "boolean"
                    },
                    "checks": {
                        "description": "Extra Soda checks for this column",
                        "type": "array",
                        "items": {
                            "allOf": [{ "$ref": "#/$defs/common_check_properties" }]
                        },
                        "required": ["type"]
                    }
                },
                "required": ["name"]
            }
        },
        "checks": {
            "description": "A list of checks for this dataset executed by a Soda",
            "type": "array",
            "items": {
                "allOf": [
                    {
                        "$ref": "#/$defs/common_check_properties"
                    },
                    {
                        "type": "object",
                        "properties": {
                            "column": {
                                "description": "The column name for the metric",
                                "type": "string"
                            }
                        }
                    }
                ],
                "required": ["type"]
            }
        }
    },
    "required": ["dataset", "columns"],
    "$defs": {
        "numeric_range": {
            "anyOf": [
                {
                    "type": "array",
                    "items": {
                        "type": "number"
                    },
                    "minLength": 2,
                    "maxLength": 2
                },
                {
                    "type": "object",
                    "description": "Nested range thresholds to customize inclusion and exclusion of boundaries",
                    "properties": {
                        "min_included": {
                            "type": "number"
                        },
                        "min_excluded": {
                            "type": "number"
                        },
                        "max_included": {
                            "type": "number"
                        },
                        "max_excluded": {
                            "type": "number"
                        }
                    },
                    "minItems": 2,
                    "maxItems": 2
                }
            ]
        },
        "format": {
            "type": "string",
            "enum": [
                "integer", "positive integer", "negative integer", "decimal", "positive decimal",
                "negative decimal", "decimal point", "positive decimal point", "negative decimal point",
                "decimal comma", "positive decimal comma", "negative decimal comma", "percentage",
                "positive percentage", "negative percentage", "percentage point",
                "positive percentage point", "negative percentage point", "percentage comma",
                "positive percentage comma", "negative percentage comma", "money", "money point",
                "money comma", "date us", "date eu", "date inverse", "date iso 8601", "time 24h",
                "time 24h nosec", "time 12h", "time 12h nosec", "timestamp 24h", "timestamp 12h",
                "uuid", "ip address", "ipv4 address", "ipv6 address", "email", "phone number",
                "credit card number"
            ]
        },
        "common_check_properties": {
            "type": "object",
            "properties": {
                "type": {
                    "description": "The type of the check, usually this is the name of the metric",
                    "anyOf": [
                        {
                            "type": "string",
                            "enum": [
                                "row_count", "freshness_in_days", "freshness_in_hours",
                                "avg", "avg_length", "duplicate_count", "duplicate_percent", "invalid_count",
                                "invalid_percent", "max", "max_length", "min", "min_length", "missing_count",
                                "missing_percent", "percentile", "stddev", "stddev_pop", "stddev_samp", "sum",
                                "variance", "var_pop", "var_samp", "failed_rows"
                            ]
                        },
                        {
                            "type": "string"
                        }
                    ]
                },
                "name": {
                    "description": "The display name for the check used in Soda Cloud and other UI tools",
                    "type": "string"
                },
                "filter_sql_expression": {
                    "description": "Specifies a sql expression filter that should be applied on the metric",
                    "type": "string"
                },
                "fail_when_is": {
                    "description": "Specifies the threshold for the check. The check fails if the metric value is the specified threshold value.",
                    "type": "number"
                },
                "fail_when_is_not": {
                    "description": "Specifies the threshold for the check. The check fails if the metric value is not the specified threshold value.",
                    "type": "number"
                },
                "fail_when_greater_than": {
                    "description": "Specifies the threshold for the check. The check fails if the metric value is greater than the specified threshold value.",
                    "type": "number"
                },
                "fail_when_greater_than_or_equal": {
                    "description": "Specifies the threshold for the check. The check fails if the metric value is greater than or equal to the specified threshold value.",
                    "type": "number"
                },
                "fail_when_less_than": {
                    "description": "Specifies the threshold for the check. The check fails if the metric value is less than the specified threshold value.",
                    "type": "number"
                },
                "fail_when_less_than_or_equal": {
                    "description": "Specifies the threshold for the check. The check fails if the metric value is less than or equal to the specified threshold value.",
                    "type": "number"
                },
                "fail_when_between": {
                    "description": "Specifies a threshold range for the check. The check fails if the metric value is between a minimum and maximum value. In short style eg fail_when_between:[10,20] boundary values 10 and 20 will pass. For including boundary values, use nested min_* and max_* properties",
                    "$ref": "#/$defs/numeric_range"
                },
                "fail_when_not_between": {
                    "description": "Specifies a threshold range for the check. The check fails if the metric value is not between a minimum and maximum value. In short style eg fail_when_between:[10,20] boundary values 10 and 20 will pass. For including boundary values, use nested min_* and max_* properties",
                    "$ref": "#/$defs/numeric_range"
                },
                "change_over_time_avg_of_last_days": {
                    "description": "The number of days for which the average should be taken as basis for comparison",
                    "type": "number"
                },
                "change_over_time_min_of_last_days": {
                    "description": "The number of days for which the minimum should be taken as basis for comparison",
                    "type": "number"
                },
                "change_over_time_max_of_last_days": {
                    "description": "The number of days for which the maximum should be taken as basis for comparison",
                    "type": "number"
                }
            },
            "required": ["type"]
        }
    }
}
